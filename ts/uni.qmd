---
title: "Univariate TS Models(ARIMA/SARIMA)"
format: html
---

::: {.callout-note appearance="simple"}

# note

In the EDA part, there is stationary observed from ACF and PACF plot except seoul housing index. Also ADF test(after differencing) confirms this with significant low p-value. To check further specifically seoul housing index, first part of this section is performing second order differencing. 

:::



### package needed 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true
library(fpp3)  
library(feasts) 
library(tsibble)
library(tidyverse)
library(lubridate)
library(zoo)       
library(forecast)   
library(tseries)   
library(patchwork) 
library(here)
library(plotly)
library(xts)
library(dplyr)
library(ggplot2)
library(ggfortify)
library(knitr)
library(kableExtra)
library(astsa)
library(fpp2)
# calling data

#KR base rate
bok<- read.csv("../data/interest/bok.csv")%>%
  rename(Date = date)
bok$Date<- as.Date(bok$Date)
bok <- bok %>%
  mutate(Date = floor_date(Date, unit = "quarter")) %>%
  group_by(Date) %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")


# FED rate 

usr<- read.csv("../data/interest/us_rate.csv")%>%
  rename(Date = observation_date,rate = DFF)
usr$Date<- as.Date(usr$Date)
usr<- usr %>%
  mutate(Date = floor_date(Date, unit = "quarter")) %>%
  group_by(Date) %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")

# KRW/USD rate

kr <- read.csv("../data/fx rate/kor.csv")
kr <- kr %>%
  transmute(
    Date = as.Date(observation_date),
    krw  = DEXKOUS,    
    usd  = 1 / DEXKOUS  
  ) %>%
  filter(!is.na(Date)) %>%
  arrange(Date) %>%
  distinct(Date, .keep_all = TRUE) %>%
  complete(Date = seq(min(Date), max(Date), by = "day")) %>%

  fill(krw, usd, .direction = "down")


# USD index 

usd <- read_csv("../data/fx rate/usd_index.csv", show_col_types = FALSE)
usd <- usd %>%
  transmute(
    Date = as.Date(Date),
    usd_index = Close
  ) %>%
  filter(!is.na(Date)) %>%
  arrange(Date) %>%
  distinct(Date, .keep_all = TRUE) %>%
  complete(Date = seq(min(Date), max(Date), by = "day")) %>%
  fill(usd_index, .direction = "down")



# Seoul housing data

housing <- read_csv(here("data/housing/house.csv")) %>%
  mutate(Date = as.Date(Date))

housing <- housing %>% mutate(Date = as.Date(Date))


# Yield data 

us_yield  <- read.csv(here("data/yield", "us_yield.csv"))
kor_yield   <- read.csv(here("data/yield", "kor_yield.csv"))


us_yield$Date  <- as.Date(us_yield$Date)
kor_yield$Date <- as.Date(kor_yield$Date)

colnames(us_yield)[colnames(us_yield)  == "X3Y"]  <- "US_3Y"
colnames(us_yield)[colnames(us_yield)  == "X10Y"] <- "US_10Y"
colnames(kor_yield)[colnames(kor_yield) == "X3Y"]  <- "KR_3Y"
colnames(kor_yield)[colnames(kor_yield) == "X10Y"] <- "KR_10Y"

us_yield  <- us_yield[,  c("Date", "US_3Y", "US_10Y")]
kor_yield <- kor_yield[, c("Date", "KR_3Y", "KR_10Y")]

us_yield  <- us_yield  %>% arrange(Date) %>% fill(US_3Y, US_10Y, .direction = "down")
kor_yield <- kor_yield %>% arrange(Date) %>% fill(KR_3Y, KR_10Y, .direction = "down")


df <- merge(us_yield, kor_yield, by = "Date")

df$US_3m10  <- df$US_3Y - df$US_10Y
df$KR_3m10  <- df$KR_3Y - df$KR_10Y
df$US_KR_3Y <- df$US_3Y - df$KR_3Y
df$US_KR_10Y<- df$US_10Y - df$KR_10Y


#import & export data 

imports <- read_csv(here::here("data/trade", "imports.csv"))
exports <- read_csv(here::here("data/trade", "exports.csv"))

clean_date <- function(x) {
  as.Date(paste0(sub("^([0-9]{4})([0-9]{2})$", "\\1-\\2", gsub("/", "-", as.character(x))), "-01"))
}

imports <- imports %>%
  mutate(Date = clean_date(Date),
         Type = "Imports")

exports <- exports %>%
  mutate(Date = clean_date(Date),
         Type = "Exports")
trade <- bind_rows(imports, exports)

names(trade)[2] <- "Value"

trade_ts <- trade %>%
  as_tsibble(index = Date, key = Type)


# S&P500 data
sp500 <- read_csv("../data/stock/sp500.csv")


# KOSPI data
kospi <- read_csv("../data/stock/kospi.csv")
kospi$Date <- as.Date(kospi$Date)

```


# Differencing


::: panel-tabset


### South korea base rate

```{r,message = F, warning = F}
#| echo: true
#| code-fold: true


bok_ts <- ts(bok$base_rate, start = c(year(min(bok$Date)), month(min(bok$Date))), end = c(year(max(bok$Date)), month(max(bok$Date))), frequency=4)
bok_diff<- diff(bok_ts,differences = 2)
ggAcf(bok_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of South Korea base rate") +
  theme_bw()

ggPacf(bok_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of South Korea base rate") +
  theme_bw()
```


### Federal Reserve Rate 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


usr_ts <- ts(usr$rate, start = c(year(min(usr$Date)), month(min(usr$Date))), end = c(year(max(usr$Date)), month(max(usr$Date))),frequency= 4)
usr_diff<- diff(usr_ts,differences = 2)

ggAcf(usr_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of Federal Reserve Rate ") +
  theme_bw()

ggPacf(usr_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of Federal Reserve Rate ") +
  theme_bw()
```


### KRW/USD FX rate

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true


kr_ts<- ts(kr$usd, frequency = 252, start = c(year(min(kr$Date)), month(min(kr$Date))), end = c(year(max(kr$Date)), month(max(kr$Date))))
kr_diff<- diff(kr_ts,differences = 2)

ggAcf(kr_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of KRW/USD FX rate") +
  theme_bw()

ggPacf(kr_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of  KRW/USD FX rate") +
  theme_bw()
```


### trade import South Korea vs USA

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

import_ts<- ts(imports$USD, frequency = 12, start = c(year(min(imports$Date)), month(min(imports$Date))), end = c(year(max(imports$Date)), month(max(imports$Date))))
import_diff <- diff(import_ts,differences = 2)

ggAcf(import_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of trade import South Korea vs USA") +
  theme_bw()

ggPacf(import_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of trade import South Korea vs USA") +
  theme_bw()
```


### trade export South Korea vs USA

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

export_ts<- ts(exports$USD, frequency = 12, start = c(year(min(exports$Date)), month(min(exports$Date))), end = c(year(max(exports$Date)), month(max(exports$Date))))
export_diff <- diff(export_ts,differences = 2)

ggAcf(export_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of trade export South Korea vs USA") +
  theme_bw()

ggPacf(export_diff) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of trade export South Korea vs USA") +
  theme_bw()
```


### USA & South Korea yield spread rate(3Y)

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

yield_3y_ts<- ts(df$US_KR_3Y, frequency = 252, start = c(year(min(df$Date)), month(min(df$Date))), end = c(year(max(df$Date)), month(max(df$Date))))
yield_3y_ts_diff <- diff(yield_3y_ts,differences = 2)

ggAcf(yield_3y_ts_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of USA & South Korea yield spread rate(3Y)") +
  theme_bw()

ggPacf(yield_3y_ts_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of USA & South Korea yield spread rate(3Y)") +
  theme_bw()
```


### USA & South Korea yield spread rate(10Y)

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

yield_10y_ts<- ts(df$US_KR_10Y, frequency = 252, start = c(year(min(df$Date)), month(min(df$Date))), end = c(year(max(df$Date)), month(max(df$Date))))
yield_10y_ts_diff <- diff(yield_10y_ts,differences = 2)

ggAcf(yield_10y_ts_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of USA & South Korea yield spread rate(10Y)") +
  theme_bw()

ggPacf(yield_10y_ts_diff,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of USA & South Korea yield spread rate(10Y)") +
  theme_bw()
```



### Seoul housing  property index 

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

house_ts<- ts(housing$housing, frequency = 12, start = c(year(min(housing$Date)), month(min(housing$Date))), end = c(year(max(housing$Date)), month(max(housing$Date))))
house_dlog <- diff(house_ts,differences = 2)

ggAcf(house_dlog) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of Seoul housing  property index ") +
  theme_bw()

ggPacf(house_dlog) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of Seoul housing  property index ") +
  theme_bw()


adf.test(house_dlog)
```


### USD index

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

usd_ts <- ts(usd$usd_index, start = c(year(min(usd$Date)), month(min(usd$Date))), end = c(year(max(usd$Date)), month(max(usd$Date))), frequency = 252)
usd_log  <- log(usd_ts)
usd_dlog <- diff(usd_log,diff = 2) 

ggAcf(usd_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of USD index") +
  theme_bw()

ggPacf(usd_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of USD index") +
  theme_bw()
```


### KOSPI index 

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

kospi_ts <- ts(kospi$Close, start = c(year(min(kospi$Date)), month(min(kospi$Date))), end = c(year(max(kospi$Date)), month(max(kospi$Date))), frequency = 250)
kospi_log  <- log(kospi_ts)
kospi_dlog <- diff(kospi_log,differences = 2) 

ggAcf(kospi_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of KOSPI index") +
  theme_bw()

ggPacf(kospi_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(2): PACF of KOSPI index") +
  theme_bw()
```

### S&P500 index

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true


sp_ts <- ts(sp500$Close, start = c(year(min(sp500$Date)), month(min(sp500$Date))), end = c(year(max(sp500$Date)), month(max(sp500$Date))), frequency = 252)
sp_log  <- log(sp_ts)
sp_dlog <- diff(sp_log,differences = 2) 

ggAcf(sp_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(2): ACF of S&P500 index") +
  theme_bw()

ggPacf(sp_dlog,lag.max = 50) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced (2): PACF of S&P500 index") +
  theme_bw()
```

:::

In the previous EDA section, we examined ACF & PACF plot before and after differencing. before starting univariate time series analysis, it is important whether differenced result is satisfied for choosing parameter for univariate time series analysis.

Table above is a  ACF & PACF plot for differencing, but this time, using second order differencing. 
In the EDA section, seoul housing index was still suspected non-stationary after first differencing, and in the second differencing,it seems it gives different result. The ACF shows small correlations scattered throughout the lags, with most staying within the confidence bounds. There are some noticeable spikes at lags around 10, 12-13, 16, 18, and 21, but these are relatively modest in magnitude (mostly under 0.15). The overall pattern shows no strong persistence or decay structure. The PACF displays a similar pattern with scattered small spikes, with a notable negative spike at lag 12 (approximately -0.20) and positive spikes at lags 16 and 18. Most other lags remain within the confidence bounds.So second-order differenced series appears to be stationary.

although ADF test result and ACF & PACF plot tells first order differencing(for some variables, log transformation was also done) is enough,except seoul housing index, to make firm decision on parameters, this table has been added. from the plots, it seems that taking second order differencing doesn't improve significantly for other variables, so for univariate time series, first order differencing will be used for determining model parameters. 

Based on the result, next step is to find model selection and its parameter. Table below are the parameters will be used for search algorithm for each data. 


## Model choices

| Series | Model parameters|
|:-------|:------------:|
| South Korea base rate | ARIMA  p = 0,1 d = 1 ,q = 0,1 |
|FED effective rate  | ARIMA  p = 0,1,2 , d = 0,1 , q = 0,1,2 |
| KRW/USD FX rate | ARIMA  p = 0,1 d = 0,1 q =  0,1 |
| Yield spread 3Y (US–KR) | ARIMA p = 0,1 d = 1  q = 0,1|
| Yield spread 10Y (US–KR) | ARIMA  p = 0,1 d = 1  q = 0,1|
| USD index (log) | ARIMA p = 0,1  d =  1, , q = 0,1|
| KOSPI index (log) | ARIMA p = 0,1 d = 1,q = 0,1,2 |
| S&P 500 index (log) | ARIMA p = 0,1 d = 0,1,  q =  0,1 |
|trade export KOR - USA| SARIMA  p = 0,1,d = 0,1 q = 0,1, P = 0,1,2,3 D = 0,1,Q = 0,1 , s= 12|
|trade import KOR -USA | SARIMA  p = 0,1,d = 0,1 q = 0,1, P = 0,1,2 D = 0,1,Q = 0,1, s = 12|
| Seoul housing property index | SARIMA p =0,1 ,d = 0,1,2 q = 0,1,2  P = 0,1, D = 0,1 ,Q = 0,1,2 ,s = 12|
: Model & Parameter selection (USD, KOSPI, and S&P500 are log-transformed before differencing.)




# Model selection


### ARIMA utility function

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true
#| results: asis

library(kableExtra)

arima_grid <- function(ts_obj,
                           p_set, d_set, q_set,
                           caption1 = NULL,
                           caption2 = "Comparison of ARIMA Models") {
  ARIMA_fit <- list()
  
  n <- length(p_set) * length(d_set) * length(q_set)

  results_matrix <- matrix(NA_real_, nrow = n, ncol = 6)
  
  cc <- 1
  
  for (d in d_set) {
    for (p in p_set) {
      for (q in q_set) {
        model <- Arima(ts_obj, order = c(p, d, q), include.drift = (d > 0))
        ARIMA_fit[[cc]] <- model
        results_matrix[cc, ] <- c(p, d, q, model$aic, model$bic, model$aicc)
        cc <- cc + 1
      }
    }
  }
  
  results_df <- as.data.frame(results_matrix)
  colnames(results_df) <- c("p","d","q","AIC","BIC","AICc")
  

  highlight_row <- which.min(results_df$AIC)
  
cap <- if (!is.null(caption1) && nzchar(caption1)) {
    sprintf("%s : %s", caption1, caption2)
  } else {
    caption
  }
  result_table<-knitr::kable(results_df, align = 'c', caption = cap) %>%
    kable_styling(full_width = FALSE, position = "center") %>%
  row_spec(highlight_row, bold = TRUE, background = "#FFFF99")
  
  list(
    table = result_table,
    best_model = ARIMA_fit[[highlight_row]],
    best_row = results_df[highlight_row, , drop = FALSE]
  )
  

}

```


:::  panel-tabset

### South korea base rate 
```{r,message = F,waring = F}
#| echo: true
#| code-fold: true

fit_kor_base <- arima_grid(
  ts_obj = kr_ts,
  p_set = c(0,1), d_set = c(1), q_set = c(0,1),
  caption1 = "South Korea Base Rate "
)
fit_kor_base$table
print(fit_kor_base$best_model)
```

Model : ARIMA(0,1,1)
 
 
$$
Equation: x_t = 1.0000x_{t-1} + w_t + 0.0161w_{t-1}
$$


### Federal reserve  rate

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true

fit_usr <- arima_grid(
  ts_obj = usr_ts,
  p_set = c(0,1), d_set = c(1), q_set = c(0,1,2),
  caption1 = "FED rate"
)
fit_usr$table
print(fit_usr$best_model)
```


Model: ARIMA(1,1,0) 

$$
Equation:\; x_t = x_{t-1} + 0.6987(x_{t-1} - x_{t-2}) + 0.0229 + w_t
$$

### KRW/USD FX rate

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true
 

fit_kr <- arima_grid(
  ts_obj = kr_ts,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1),
  caption1 = "KRW/USD FX rate"
)
fit_kr$table
print(fit_kr$best_model)

```

Model: ARIMA(1,0,1)

$$
Equation:\; x_t = 0.9997x_{t-1} + w_t + 0.0165w_{t-1} + 0.0011
$$




### USA & South Korea yield spread rate(3Y)

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true
 

fit_yield_3y <- arima_grid(
  ts_obj = yield_3y_ts,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1),
  caption1 = "USA & South Korea yield spread rate(3Y)"
)
fit_yield_3y$table
print(fit_yield_3y$best_model)


```

Model : ARIMA(0,1,1)


$$
Equation:\; x_t = x_{t-1} - 0.0002 + w_t - 0.1069w_{t-1}
$$



### USA & South Korea yield spread rate(10Y)

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true
 

fit_yield_10y <- arima_grid(
  ts_obj = yield_10y_ts,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1),
  caption1 = "USA & South Korea yield spread rate(10Y)"
)

fit_yield_10y$table
print(fit_yield_10y$best_model)


```


Model : ARIMA(1,0,1)

$$
Equation:\; x_t = 0.9968x_{t-1} + w_t - 0.0896w_{t-1} - 0.7027
$$




### USD index

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true

fit_usd_index <- arima_grid(
  ts_obj = usd_log,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1),
  caption1 = "USD Index (log)"
)
fit_usd_index$table
print(fit_usd_index$best_model)

```


Model: ARIMA(1,0,0)

$$
Equation:\; x_t = 0.9997x_{t-1} + 4.5713 + w_t
$$



### S&P500 index 

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true

fit_sp500 <- arima_grid(
  ts_obj = sp_log,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1),
  caption1 = "S&P 500 Index (log)"
)
fit_sp500$table
print(fit_sp500$best_model)
```

Model: ARIMA(0,1,1)

$$
Equation:\; x_t = x_{t-1} + 0.0003 + w_t - 0.0802w_{t-1}
$$


### KOSPI index 

```{r,message = F,waring = F}
#| echo: true
#| code-fold: true

fit_kospi <- arima_grid(
  ts_obj = kospi_log,
  p_set = c(0,1), d_set = c(0,1), q_set = c(0,1,2),
  caption1 = "KOSPI Index (log)"
)

fit_kospi$table
print(fit_kospi$best_model)

```


Model : ARIMA(0,1,2)


$$
Equation:\; x_t = x_{t-1} + 0.0000 + w_t + 0.0258w_{t-1} - 0.0214w_{t-2}
$$


:::










# SARIMA Model

### ACF & PACF plot for seasonal data 

::: panel-tabset 



### trade import South Korea vs USA

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true

import_diff_seasonal <- diff(import_ts,lag = 12)

ggAcf(import_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(seasonal): ACF of trade import South Korea vs USA") +
  theme_bw()

ggPacf(import_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(seasonal): PACF of trade import South Korea vs USA") +
  theme_bw()
```


### trade export South Korea vs USA

```{r,warning = F,message = F}
#| echo: true
#| code-fold: true


export_diff_seasonal <- diff(export_ts,lag = 12)

ggAcf(export_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(seasonal): ACF of trade export South Korea vs USA") +
  theme_bw()

ggPacf(export_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(seasonal): PACF of trade export South Korea vs USA") +
  theme_bw()
```



### Seoul housing  property index

```{r,message = F,warning= FALSE}
#| echo: true
#| code-fold: true

house_diff_seasonal <- diff(house_ts,lag = 12)

ggAcf(house_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="blue") +
  labs(title = "Differenced(seasonal): ACF of Seoul housing  property index ") +
  theme_bw()

ggPacf(house_diff_seasonal) +
  geom_segment(aes(xend = lag, yend = 0), color="red") +
  labs(title = "Differenced(seasonal): PACF of Seoul housing  property index ") +
  theme_bw()
```

:::


### SARIMA utility function

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true
#| results: asis


library(kableExtra)

sarima_grid <- function(ts_obj,
                            p_set, d_set, q_set,
                            P_set, D_set, Q_set, s,
                            caption_prefix = NULL,
                            caption_suffix = "Comparison of SARIMA Model"){
  SARIMA_fit <- list()
  n <- length(p_set) * length(d_set) * length(q_set) *
       length(P_set) * length(D_set) * length(Q_set)
  results_matrix <- matrix(NA_real_, nrow = n, ncol = 9) 
  cc <- 1


  for (d in d_set) {
    for (p in p_set) {
      for (q in q_set) {
        for (P in P_set) {
          for (D in D_set) {
            for (Q in Q_set) {
              model <- Arima(ts_obj,
                             order   = c(p, d, q),
                             seasonal = list(order = c(P, D, Q), period = s),
                              method = "ML",             
          transform.pars = TRUE )
              SARIMA_fit[[cc]] <- model
              results_matrix[cc, ] <- c(p, d, q, P, D, Q, model$aic, model$bic, model$aicc)
              cc <- cc + 1
            }
          }
        }
      }
    }
  }

  results_df <- as.data.frame(results_matrix)
  colnames(results_df) <- c("p","d","q","P","D","Q","AIC","BIC","AICc")
  highlight_row <- which.min(results_df$AIC)

  cap <- if (!is.null(caption_prefix) && nzchar(caption_prefix)) {
    sprintf("%s : %s", caption_prefix, caption_suffix)
  } else {
    caption_suffix
  }

  result_table1 <-knitr::kable(results_df, align = 'c', caption = cap) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center") %>%
  kableExtra::row_spec(highlight_row, bold = TRUE, background = "#FFFF99")
  

 list(
    table = result_table1,
    best_model = SARIMA_fit[[highlight_row]],
    best_row = results_df[highlight_row, , drop = FALSE]
  )
  

}




```




::: panel-tabset 

### Trade import South korea vs USA  

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


fit_import <- sarima_grid(
  ts_obj = import_ts,
  p_set = c(0,1), d_set = c(1), q_set = c(0,1,2),
  P_set = c(0,1), D_set = c(1), Q_set = c(0,1), s = 12,
  caption_prefix = "Trade import South korea vs USA "
)
fit_import$table
print(fit_import$best_model)
```

Model : SARIMA(0,1,2)(0,1,1)[12]

$$
Equation:\; (1 - B)(1 - B^{12})x_t = (1 - 0.5291B + 0.1363B^2)(1 - 0.9351B^{12})w_t
$$


###  Trade export South korea vs USA  

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

fit_export<- sarima_grid(
  ts_obj = export_ts,
  p_set = c(0), d_set = c(0,1), q_set = c(0,1,2,3),
  P_set = c(0), D_set = c(0,1), Q_set = c(0,1), s = 12,
  caption_prefix = " Trade export South korea vs USA  "
)
fit_export$table
print(fit_export$best_model)
```

Model : SARIMA(0,1,1)(0,1,1)[12] 

$$
Equation:\; (1 - B)(1 - B^{12})x_t = (1 - 0.5536B)(1 - 0.8441B^{12})w_t
$$


### Seoul housing property index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

fit_housing <- sarima_grid(
  ts_obj = house_ts,
  p_set = c(0,1), d_set = c(1), q_set = c(0,1,2),
  P_set = c(0,1), D_set = c(1), Q_set = c(0,1,2), s = 12,
  caption_prefix = "seoul housing property index"
)
fit_housing$table
print(fit_housing$best_model)

```

Model : SARIMA(1,1,2)(0,1,1)[12]

$$
Equation:\; (1 - 0.7799B)(1 - B)(1 - B^{12})x_t = (1 + 0.2868B + 0.1734B^2)(1 - 0.9998B^{12})w_t
$$


:::


## Model choice(with equation)

- South korea base rate 

 Model : ARIMA(0,1,1)
  
$$
Equation: x_t = 1.0000x_{t-1} + w_t + 0.0161w_{t-1}
$$

- Federal reserve  rate

 Model: ARIMA(1,1,0) 

$$
Equation:\; x_t = x_{t-1} + 0.6987(x_{t-1} - x_{t-2}) + 0.0229 + w_t
$$

- KRW/USD FX rate

 Model: ARIMA(1,0,1)

$$
Equation:\; x_t = 0.9997x_{t-1} + w_t + 0.0165w_{t-1} + 0.0011
$$

- USA & South Korea yield spread rate(10Y)

 Model : ARIMA(1,0,1)

$$
Equation:\; x_t = 0.9968x_{t-1} + w_t - 0.0896w_{t-1} - 0.7027
$$

- USD index

 Model: ARIMA(1,0,0)

$$
Equation:\; x_t = 0.9997x_{t-1} + 4.5713 + w_t
$$

- S&P500 index 

 Model: ARIMA(0,1,1)

$$
Equation:\; x_t = x_{t-1} + 0.0003 + w_t - 0.0802w_{t-1}
$$

- KOSPI index 

 Model : ARIMA(0,1,2)

$$
Equation:\; x_t = x_{t-1} + 0.0000 + w_t + 0.0258w_{t-1} - 0.0214w_{t-2}
$$

- Trade import South korea vs USA  Model 

 SARIMA(0,1,2)(0,1,1)[12]

$$
Equation:\; (1 - B)(1 - B^{12})x_t = (1 - 0.5291B + 0.1363B^2)(1 - 0.9351B^{12})w_t
$$

- Trade import South korea vs USA  

 Model : SARIMA(0,1,1)(0,1,1)[12] 

$$
Model : SARIMA(0,1,1)(0,1,1)[12] \
Equation:\; (1 - B)(1 - B^{12})x_t = (1 - 0.5536B)(1 - 0.8441B^{12})w_t
$$

- Seoul housing property index 

Model : SARIMA(1,1,2)(0,1,1)[12]

$$
Equation:\; (1 - 0.7799B)(1 - B)(1 - B^{12})x_t = (1 + 0.2868B + 0.1734B^2)(1 - 0.9998B^{12})w_t
$$



# Model diagnostics


::: panel-tabset


### South korea base rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

bok_model<- capture.output(sarima(bok_ts, 0,1,1))

```

The residual diagnostics for the ARIMA(0,1,1) model indicate a fairly good fit. The standardized residuals fluctuate randomly around zero, suggesting the mean of the residuals is stable over time. However there are outlier times for example around 2019 and 2025 Q1. The ACF plot shows no significant spikes beyond the 95% confidence limits, implying that the residuals are uncorrelated and behave like white noise. The Q–Q plot of standardized residuals is mostly linear, though with slight deviations at the tails, indicating mild non-normality. The Ljung–Box test p-values remain above 0.05 across lags, confirming that there is no significant autocorrelation left in the residuals. 

###  Federal Reserve rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

usr_model<- capture.output(sarima(usr_ts, 1, 1, 0))

```

The residuals from the ARIMA(1,1,0) model are well-behaved and largely centered around zero, with only a few spikes visible around 2009 and 2020. The ACF plot reveals no substantial autocorrelation at any lag, supporting the conclusion that the residuals are random and independent. The Q–Q plot demonstrates a near-linear relationship between sample and theoretical quantiles, except for small departures at both ends of the distribution, which suggests slight heavy-tailed behavior. The Ljung–Box p-values mostly exceed 0.05, indicating the residuals are effectively white noise. This model performs well and adequately represents the time series dynamics, with minimal room for improvement.


### KRW/USD FX rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

kr_model<- capture.output(sarima(kr_ts, 1,0,1))

```

For the ARMA(1,0,1) model, the residuals fluctuate around zero but exhibit slightly higher volatility than desired, particularly during certain time intervals. The ACF of the residuals shows weak but visible autocorrelation at the first few lags.  The Q–Q plot displays substantial deviation from the 45-degree line in the tails, implying the presence of heavy tails and possible outliers, showing non-linearity. The Ljung–Box test results show a few p-values below the 0.05 threshold, which further indicates some remaining structure in the residuals. In summary, while the model fits decently, it may not fully capture the short-term autocorrelation and could benefit from a slightly more complex specification.


### trade import South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

import_model<- capture.output(sarima(import_ts, 0,1,2,0,1,1,12))

```

The SARIMA(0,1,2)×(0,1,1)[12] model shows residuals that are roughly centered around zero, though some mild volatility clustering is visible toward the end of the series. The ACF plot exhibits small but notable spikes at seasonal lags.  The Q–Q plot suggests that the residuals in heavier tails at the extremes, shows non-linearity. The Ljung–Box test indicates that many p-values are below 0.05, suggesting the presence of lingering autocorrelation, indicating it is not fully capturing underlying structure of time series .

### trade export South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

export_model<- capture.output(sarima(export_ts, 0,1,1,0,1,1,12))

```

The SARIMA(0,1,1)×(0,1,1)[12] model shows residuals that are roughly centered around zero, though some mild volatility clustering is visible toward the end of the series. The ACF plot exhibits small but notable spikes at seasonal lags.  The Q–Q plot suggests that the residuals in heavier tails at the extremes, shows non-linearity. The Ljung–Box test indicates that many p-values are below 0.05, suggesting the presence of lingering autocorrelation, indicating it is not fully capturing the underlying structure of time series .


### USA & South korea yield spread rate(3y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

yield_3y_model<- capture.output(sarima(yield_3y_ts, 0, 1, 1))
```

The ARIMA(0,1,1) model shows residuals that  are roughly centered around zero(with one outlier), showing no trend or nonstationarity. The ACF plot is nearly flat, with no significant spikes, suggesting residual independence. The Q–Q plot, however, reveals heavier lower tails, indicating a non-normal distribution. The Ljung–Box test p-values fluctuate around the 0.05 line but mostly remain above it, meaning there is no strong evidence of autocorrelation, it is best to interpret as weak autocorrelation. 

### USA & South korea yield spread rate(10y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

yield_10y_model<- capture.output(sarima(yield_10y_ts, 1, 0, 1))

```

The ARIMA(1,0,1) model shows residuals that  are roughly centered around zero(with one outlier), showing no trend or nonstationarity. The ACF plot is nearly flat, with no significant spikes, suggesting residual independence. The Q–Q plot, however, reveals heavier lower tails, indicating a non-normal distribution. The Ljung–Box test p-values fluctuate around the 0.05 line but mostly remain above it, meaning there is no strong evidence of autocorrelation, it is best to interpret as weak autocorrelation. 

### seoul housing property index

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

house_model<- capture.output(sarima(house_ts, 1, 1, 2,0,1,1,12))

```

The residual diagnostics for the SARIMA(1,1,2)×(0,1,1)[12] model indicate a strong overall fit. The standardized residuals are well-centered and show no visible trend or heteroskedasticity.However since there are fluctuations, it is possible to suspect the fit of the model. The ACF plot reveals that all autocorrelations fall within the confidence bounds, demonstrating that the residuals are uncorrelated. The Q–Q plot is slight deviations at the tails, close to normal, but non-normal. The Ljung–Box test p-values are all above 0.05, suggesting that there is no evidence of autocorrelation remaining. 

### USD index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

usd_model<- capture.output(sarima(usd_log, 1,0,0))

```

The ARIMA(1,0,0) model produces residuals that fluctuate around zero without clear patterns, indicating good fit of the model. The ACF of the residuals is nearly flat, with no significant spikes, indicating that the model successfully removed most autocorrelation. The Q–Q plot shows heavy tails and slight skewness, implying some non-normality. The Ljung–Box p-values are above 0.05 but close to 0.05, meaning there is weak sign of autocorrelation left in the residuals. 

### KOSPI index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


kospi_model<- capture.output(sarima(kospi_log, 0,1,2))

```

The ARIMA(0,1,2) model demonstrates residuals that are mostly stable and centered around zero, with one outlier spike. The ACF plot indicates that residuals are largely uncorrelated, as no autocorrelation exceeds the 95% bounds. The Q–Q plot reveals noticeable deviations at the extremes, with heavy tails indicating non-normal residuals. Ljung–Box test results suggest that most p-values clearly are above 0.05, confirming no remaining autocorrelation. 

### S&P500 index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

sp_model<- capture.output(sarima(sp_log, 0,1, 1))

```

The residual diagnostics for the ARIMA(0,1,1) model indicate that it fits the data reasonably well. The standardized residuals fluctuate randomly around zero with stable variance, though a few volatility spikes appear around 2008–2010 and after 2020. The ACF of residuals shows no significant autocorrelation, suggesting that the residuals behave like white noise. The Normal Q–Q plot is mostly linear but deviates slightly at the tails, indicating heavier tails and mild non-normality. The Ljung–Box p-values remain above 0.05 in the first few lags and are close to 0.05 or less ,autocorrelation exists in the residuals, suggesting the model has not fully captured the underlying structure of the time series.


:::




# AUTO.ARIMA


::: panel-tabset


### South korea base rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(bok_ts)

```

###  Federal Reserve rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(usr_ts)

```

### KRW/USD FX rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(kr_ts)

```

### trade import South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(import_ts)

```


### trade export South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(export_ts)

```

### USA & South korea yield spread rate(3y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(yield_3y_ts)

```

### USA & South korea yield spread rate(10y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(yield_10y_ts)

```

### seoul housing property index

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(house_ts)

```

### USD index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(usd_log)

```

### KOSPI index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(kospi_log)

```


### S&P500 index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

auto.arima(sp_log)

```

:::


### discrepancy between model selection process and auto.arima 

Both model selection procedure and auto.arima() recommend models, but they weigh evidence differently, so agreement occurs only where the diagnostics are unequivocally clean. For the Federal Reserve rate, trade imports, KOSPI, and S&P 500, residual checks are tidy—flat residual ACFs, Ljung–Box p-values consistently above 0.05, and only mild Q–Q tail bends—so both methods converge on the same specifications. In contrast, several other series show diagnostic red flags that nudge the algorithms apart. The South Korea base rate looks broadly well-fit but exhibits outlier patterns that can distort parameter selection; the FX rate has two large residual outliers and Ljung–Box p-values often below 0.05, indicating unresolved autocorrelation; exports likewise show low Ljung–Box p-values and more volatile residuals than peer models; the 10-year yield spread has one large outlier and Ljung–Box p-values that are acceptable at short lags but approach or fall below 0.05 after roughly 10 lags, again signaling remaining dependence; the Seoul housing index displays notably volatile residuals; and the USD index shows low Ljung–Box p-values, confirming residual autocorrelation. In short, where diagnostics are clean, both methods agree; where outliers, volatility, or lingering autocorrelation appear, auto.arima() tends to prefer more parsimonious models, while our approach favors specifications that better purge residual structure—hence the differences.




# Forecasting

::: panel-tabset


### South korea base rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

bok_fit <- Arima(bok_ts, order = c(0,1,1))
bok_forecast_result <- forecast(bok_fit, h = 20)
autoplot(bok_forecast_result) +
  labs(title = "ARIMA(0,1,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()
```




###  Federal Reserve rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


usr_fit <- Arima(usr_ts, order = c(1,1,0))
usr_forecast_result <- forecast(usr_fit, h = 20)
autoplot(usr_forecast_result) +
  labs(title = "ARIMA(1,1,0) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()

```

### KRW/USD FX rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

kr_fit <- Arima(kr_ts, order = c(1,0,1))
kr_forecast_result <- forecast(kr_fit, h = 1008)
autoplot(kr_forecast_result) +
  labs(title = "ARIMA(1,0,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()
```

### trade import South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

import_fit <- Arima(import_ts, order = c(0,1,2), seasonal = list(order = c(0,1,1), period = 12))
import_forecast_result <- forecast(import_fit, h = 36,level = c(80, 95))
autoplot(import_forecast_result,PI= TRUE) +
  labs(title = " SARIMA(0,1,2)(0,1,1)[12] Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()

```

### trade export South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

export_fit <- Arima(export_ts, order = c(0,1,1), seasonal = list(order = c(0,1,1), period = 12))
export_forecast_result <- forecast(export_fit, h = 36,level = c(80, 95))
autoplot(export_forecast_result,PI= TRUE) +
  labs(title = "Trade export: SARIMA(0,1,1)(0,1,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()
```

### USA & South korea yield spread rate(3y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


yield_3y_fit <- Arima(yield_3y_ts, order = c(0,1,1))
yield_3y_forecast_result <- forecast(yield_3y_fit, h = 1008)
autoplot(yield_3y_forecast_result) +
  labs(title = "ARIMA(0,1,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()
```

### USA & South korea yield spread rate(10y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

yield_10y_fit <- Arima(yield_10y_ts, order = c(1,0,1))
yield_10y_forecast_result <- forecast(yield_10y_fit, h = 1008)
autoplot(yield_10y_forecast_result) +
  labs(title = "ARIMA(1,0,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()
```

### seoul housing property index

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


house_fit <- Arima(house_ts, order = c(1,1,2), seasonal = list(order = c(0,1,1), period = 12))
house_forecast_result <- forecast(house_fit, h = 36,level = c(80, 95))
autoplot(house_forecast_result,PI= TRUE) +
  labs(title = "SARIMA(1,1,2)(0,1,1)[12] Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()

```



### USD index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


usd_fit <- Arima(usd_log, order = c(1,0,0))
usd_forecast_result_usd <- forecast(usd_fit, h = 1008)

autoplot(usd_forecast_result_usd) +
  labs(title = "ARIMA(1,0,0) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal() 

```

### KOSPI index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

kospi_fit <- Arima(kospi_log, order = c(0,1,2))
kospi_forecast_result <- forecast(kospi_fit, h = 756)
autoplot(kospi_forecast_result) +
  labs(title = "ARIMA(0,1,2) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()

```


### S&P500 index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

sp_fit <- Arima(sp_log, order = c(1,0,1))
sp_forecast_result <- forecast(sp_fit, h = 1008)
autoplot(sp_forecast_result) +
  labs(title = "ARIMA(1,0,1) Forecast",
       x = "Time",
       y = "Predicted Values") +
  theme_minimal()

```

:::

The forecast plots for most series indicate that the models are performing well. The shaded gray bands represent confidence intervals—the ranges within which future values are likely to fall—and their gradual widening over the forecast horizon reflects increasing uncertainty as predictions extend further into the future. For policy rates, which are adjusted periodically rather than daily, short-term fluctuations are naturally limited. This stability is clearly visible in the plots, where the forecast lines remain relatively smooth and the confidence intervals stay narrow over shorter horizons, reflecting the steady nature of monetary policy adjustments and the slower dynamics of interest rate changes compared with high-frequency financial data.



# Benchmark 

### plot utility function

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

plot_util <- function(forecast_result, ts, h, fit) {
  print(accuracy(forecast_result))  
  autoplot(ts) +
    autolayer(meanf(ts, h = h), series = "Mean", PI = FALSE) +
    autolayer(naive(ts, h = h), series = "Naïve", PI = FALSE) +
    autolayer(snaive(ts, h = h), series = "SNaïve", PI = FALSE) +
    autolayer(rwf(ts, drift = TRUE, h = h), series = "Drift", PI = FALSE) +
    autolayer(forecast(fit, h = h), series = "Fit", PI = FALSE) +
    xlab("Date") + 
    ylab("Predicted Values") +
    guides(colour = guide_legend(title = "Forecast Methods")) +
    theme_minimal()
}
```


::: panel-tabset



### South korea base rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


bok_tsibble<-as_tsibble(bok_ts)
fit_bok <- bok_tsibble%>%
  model(
    Mean  = MEAN(value),
    Naive = NAIVE(value),
    SNaive = SNAIVE(value),
    Drift = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))  
  )

bok_forecast <- forecast(fit_bok, h = 20)


autoplot(bok_forecast, bok_tsibble) +
  labs(x = "Quarter", y = "Predicted Values", colour = "Forecast Methods") +
    guides(colour = "none", linetype = "none") +  
  theme_minimal()

acc_train <- accuracy(fit_bok) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)

h <- 20
n <- nrow(bok_tsibble)
bok_train <- bok_tsibble %>% dplyr::slice_head(n = n - h)
bok_test  <- bok_tsibble %>% dplyr::slice_tail(n = h)

fit_train <- bok_train %>%
  model(
    Mean        = MEAN(value),
    Naive       = NAIVE(value),
    SNaive      = SNAIVE(value),
    Drift       = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))
  )

fc_test <- forecast(fit_train, h = h)

acc_test <- accuracy(fc_test, bok_test) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)
print(acc_test)

```


###  Federal Reserve rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

usr_tsibble<-as_tsibble(usr_ts)
fit_usr <- usr_tsibble%>%
  model(
    Mean  = MEAN(value),
    Naive = NAIVE(value),
    SNaive = SNAIVE(value),
    Drift = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(1,1,0))  
  )

usr_forecast <- forecast(fit_usr, h = 20)


autoplot(usr_forecast, usr_tsibble) +
  labs(x = "Quarter", y = "Predicted Values", colour = "Forecast Methods") +
    guides(colour = "none", linetype = "none") +  
  theme_minimal()


acc_train_usr <- accuracy(fit_usr) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)

h <- 20
n <- nrow(usr_tsibble)
usr_train <- usr_tsibble %>% dplyr::slice_head(n = n - h)
usr_test  <- usr_tsibble %>% dplyr::slice_tail(n = h)

fit_train_usr <- usr_train %>%
  model(
    Mean        = MEAN(value),
    Naive       = NAIVE(value),
    SNaive      = SNAIVE(value),
    Drift       = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))
  )

fc_test_usr <- forecast(fit_train_usr, h = h)

acc_test_usr <- accuracy(fc_test_usr, usr_test) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)
print(acc_test_usr)

```

### KRW/USD FX rate

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


plot_util(kr_forecast_result, kr_ts, 756, kr_fit)
```

### trade import South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

import_tsibble<-as_tsibble(import_ts)
fit_import <- import_tsibble%>%
  model(
    Mean  = MEAN(value),
    Naive = NAIVE(value),
    SNaive = SNAIVE(value),
    Drift = RW(value ~ drift()),
    ARIMA_model = ARIMA(
      value ~ pdq(0,1,2) + PDQ(0,1,1, period = 12) + drift())  
  )

import_forecast <- forecast(fit_import, h = 36)


autoplot(import_forecast, import_tsibble) +
  labs(x = "Quarter", y = "Predicted Values", colour = "Forecast Methods") +
    guides(colour = "none", linetype = "none") +  
  theme_minimal()



acc_train_import <- accuracy(fit_import) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)

h <- 36
n <- nrow(import_tsibble)
import_train <- import_tsibble %>% dplyr::slice_head(n = n - h)
import_test  <- import_tsibble %>% dplyr::slice_tail(n = h)

fit_train_import <- import_train %>%
  model(
    Mean        = MEAN(value),
    Naive       = NAIVE(value),
    SNaive      = SNAIVE(value),
    Drift       = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))
  )

fc_test_import <- forecast(fit_train_import, h = h)

acc_test_import <- accuracy(fc_test_import, import_test) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)
print(acc_test_import)
```

### trade export South Korea vs USA

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

export_tsibble<-as_tsibble(export_ts)
fit_export <- export_tsibble%>%
  model(
    Mean  = MEAN(value),
    Naive = NAIVE(value),
    SNaive = SNAIVE(value),
    Drift = RW(value ~ drift()),
    ARIMA_model = ARIMA(
      value ~ pdq(0,1,1) + PDQ(0,1,1, period = 12) + drift())  
  )

export_forecast <- forecast(fit_export, h = 36)


autoplot(export_forecast, export_tsibble) +
  labs(x = "Quarter", y = "Predicted Values", colour = "Forecast Methods") +
    guides(colour = "none", linetype = "none") +  
  theme_minimal()




acc_train_export <- accuracy(fit_export) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)

h <- 36
n <- nrow(export_tsibble)
export_train <- export_tsibble %>% dplyr::slice_head(n = n - h)
export_test  <- export_tsibble %>% dplyr::slice_tail(n = h)

fit_train_export <- export_train %>%
  model(
    Mean        = MEAN(value),
    Naive       = NAIVE(value),
    SNaive      = SNAIVE(value),
    Drift       = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))
  )

fc_test_export <- forecast(fit_train_export, h = h)

acc_test_export <- accuracy(fc_test_export, export_test) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)
print(acc_test_export)


```

### USA & South korea yield spread rate(3y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

plot_util(yield_3y_forecast_result,yield_3y_ts,756, yield_3y_fit)
```

### USA & South korea yield spread rate(10y)

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true

plot_util(yield_10y_forecast_result,yield_10y_ts,756, yield_10y_fit)
```

### seoul housing property index

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


house_tsibble<-as_tsibble(house_ts)
fit_house <- house_tsibble%>%
  model(
    Mean  = MEAN(value),
    Naive = NAIVE(value),
    SNaive = SNAIVE(value),
    Drift = RW(value ~ drift()),
    ARIMA_model = ARIMA(
      value ~ pdq(1,1,2) + PDQ(0,1,1, period = 12) + drift())  
  )

house_forecast <- forecast(fit_house, h = 36)


autoplot(house_forecast, house_tsibble) +
  labs(x = "Quarter", y = "Predicted Values", colour = "Forecast Methods") +
    guides(colour = "none", linetype = "none") +  
  theme_minimal()




acc_train_house <- accuracy(fit_house) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)

h <- 36
n <- nrow(house_tsibble)
house_train <- house_tsibble %>% dplyr::slice_head(n = n - h)
house_test  <- house_tsibble %>% dplyr::slice_tail(n = h)

fit_train_house <- house_train %>%
  model(
    Mean        = MEAN(value),
    Naive       = NAIVE(value),
    SNaive      = SNAIVE(value),
    Drift       = RW(value ~ drift()),
    ARIMA_model = ARIMA(value ~ pdq(0,1,1))
  )

fc_test_house <- forecast(fit_train_house, h = h)

acc_test_house <- accuracy(fc_test_house, house_test) %>%
  dplyr::select(.model, RMSE, MAE, MAPE, MASE, ACF1) %>%
  dplyr::arrange(RMSE)
print(acc_test_house)
```



### USD index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


plot_util(usd_forecast_result_usd, usd_log, 756, usd_fit)
```

### KOSPI index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


plot_util(kospi_forecast_result,kospi_log, 756, kospi_fit)
```


### S&P500 index 

```{r,message = F,warning = F}
#| echo: true
#| code-fold: true


plot_util(sp_forecast_result,sp_log, 756, sp_fit)

```

:::


The accuracy plots and tables tell a consistent story: at short horizons our ARIMA/SARIMA models generally deliver the lowest MAE and RMSE, sitting below the mean/naïve/seasonal-naïve/drift lines in the horizon–error charts, with the advantage tapering as the horizon lengthens. For policy rates and monthly trade series, SARIMA improves on seasonal-naïve for h≤4–6 steps, while by h≈12 the gap narrows and seasonal-naïve often matches performance. For daily FX and long-maturity yield spreads, random-walk benchmarks (naïve or ARIMA(0,1,1)) remain hard to beat—our curves largely overlap theirs beyond h≈20—so the most reliable gains appear at very short horizons. For equity indices in logs, adding drift yields small but consistent MAE/RMSE improvements up to h≈20–60, after which all models converge. Across series, prediction-interval coverage is close to nominal at short horizons and widens appropriately with h, reinforcing the visual impression from the graphs that uncertainty grows as we look further ahead.



# cross validation 


### utility function & set up



```{r,message = F,warning = F}

compare_two_models_fixedk <- function(y, fit_base, fit_alt,
                                      labels = c("Baseline","Alternative"),
                                      k = 120, s = 12, h = 12) {
  stopifnot(frequency(y) == s, k >= s, k <= length(y) - s)
  n  <- length(y)
  st <- tsp(y)[1] + (k - 2) / s
  max_origins <- n - k

  mae_b  <- matrix(NA_real_, max_origins, h)
  mae_a  <- matrix(NA_real_, max_origins, h)
  rmse_b <- matrix(NA_real_, max_origins, h)  
  rmse_a <- matrix(NA_real_, max_origins, h)

  for (i in 1:max_origins) {
    xtrain <- window(y, end = st + i / s)
    xtest  <- window(y, start = st + (i + 1) / s, end = st + (i + h) / s)
    m <- length(xtest); if (m <= 0) next

    fcb <- forecast(fit_base(xtrain), h = h)
    fca <- forecast(fit_alt(xtrain),  h = h)

    eb <- as.numeric(fcb$mean[1:m] - xtest)
    ea <- as.numeric(fca$mean[1:m] - xtest)

    mae_b[i, 1:m]  <- abs(eb)
    mae_a[i, 1:m]  <- abs(ea)
    rmse_b[i, 1:m] <- eb^2
    rmse_a[i, 1:m] <- ea^2
  }

  error_table <- tibble(
    Horizon     = 1:h,
    MAE_base    = colMeans(mae_b,  na.rm = TRUE),
    MAE_alt     = colMeans(mae_a,  na.rm = TRUE),
    RMSE_base   = sqrt(colMeans(rmse_b, na.rm = TRUE)),
    RMSE_alt    = sqrt(colMeans(rmse_a, na.rm = TRUE)),
    origins     = max_origins
  )

  mae_long <- error_table |>
    select(Horizon, MAE_base, MAE_alt) |>
    rename(!!labels[1] := MAE_base, !!labels[2] := MAE_alt) |>
    pivot_longer(-Horizon, names_to = "Model", values_to = "MAE")

  p_mae <- ggplot(mae_long, aes(x = Horizon, y = MAE, color = Model)) +
    geom_line(linewidth = 1) + geom_point(size = 1.8) +
    labs(title = "MAE Comparison (1..12 steps)",
         x = "Forecast Horizon (months ahead)", y = "MAE", color = "Models") +
    scale_color_manual(values = c("#E74C3C", "#2E86C1")) +
    theme_minimal(base_size = 13)

  rmse_long <- error_table |>
    select(Horizon, RMSE_base, RMSE_alt) |>
    rename(!!labels[1] := RMSE_base, !!labels[2] := RMSE_alt) |>
    pivot_longer(-Horizon, names_to = "Model", values_to = "RMSE")

  p_rmse <- ggplot(rmse_long, aes(x = Horizon, y = RMSE, color = Model)) +
    geom_line(linewidth = 1) + geom_point(size = 1.8) +
    labs(title = "RMSE Comparison (1..12 steps)",
         x = "Forecast Horizon (months ahead)", y = "RMSE", color = "Models") +
    scale_color_manual(values = c("#E74C3C", "#2E86C1")) +
    theme_minimal(base_size = 13)

  list(table = error_table, plot_mae = p_mae, plot_rmse = p_rmse)
}

compare_two_models_seasonal_1_vs_s <- function(y, fit_base, fit_alt,
                                               labels = c("Baseline","Alternative"),
                                               s = 12) {
  stopifnot(frequency(y) == s)
  fc_fun_b <- function(x, h) forecast(fit_base(x), h = h)
  fc_fun_a <- function(x, h) forecast(fit_alt(x),  h = h)

  e1_b <- tsCV(y, forecastfunction = fc_fun_b, h = 1)
  es_b <- tsCV(y, forecastfunction = fc_fun_b, h = s)
  e1_a <- tsCV(y, forecastfunction = fc_fun_a, h = 1)
  es_a <- tsCV(y, forecastfunction = fc_fun_a, h = s)

  metr <- function(e) c(MAE = mean(abs(e), na.rm = TRUE),
                        RMSE = sqrt(mean(e^2, na.rm = TRUE)))
  out <- tibble(
    Horizon = factor(c("1-step","s-step"), levels = c("1-step","s-step")),
    MAE_base  = c(metr(e1_b)["MAE"],  metr(es_b)["MAE"]),
    MAE_alt   = c(metr(e1_a)["MAE"],  metr(es_a)["MAE"]),
    RMSE_base = c(metr(e1_b)["RMSE"], metr(es_b)["RMSE"]),
    RMSE_alt  = c(metr(e1_a)["RMSE"], metr(es_a)["RMSE"])
  )

  mae_long <- out |>
    select(Horizon, MAE_base, MAE_alt) |>
    rename(!!labels[1] := MAE_base, !!labels[2] := MAE_alt) |>
    pivot_longer(-Horizon, names_to = "Model", values_to = "MAE")

  p_mae <- ggplot(mae_long, aes(x = Horizon, y = MAE, color = Model, group = Model)) +
    geom_line(linewidth = 1) + geom_point(size = 2) +
    labs(title = "Seasonal CV — MAE (1-step vs s-step)", x = NULL, y = "MAE", color = "Models") +
    scale_color_manual(values = c("#E74C3C", "#2E86C1")) +
    theme_minimal(base_size = 12)

  rmse_long <- out |>
    select(Horizon, RMSE_base, RMSE_alt) |>
    rename(!!labels[1] := RMSE_base, !!labels[2] := RMSE_alt) |>
    pivot_longer(-Horizon, names_to = "Model", values_to = "RMSE")

  p_rmse <- ggplot(rmse_long, aes(x = Horizon, y = RMSE, color = Model, group = Model)) +
    geom_line(linewidth = 1) + geom_point(size = 2) +
    labs(title = "Seasonal CV — RMSE (1-step vs s-step)", x = NULL, y = "RMSE", color = "Models") +
    scale_color_manual(values = c("#E74C3C", "#2E86C1")) +
    theme_minimal(base_size = 12)

  list(table = out, plot_mae = p_mae, plot_rmse = p_rmse)
}


s <- 12

fit_export_baseline <- function(x) Arima(x, order = c(0,1,1),
                                         seasonal = list(order = c(0,1,1), period = s),
                                         include.drift = FALSE)     

fit_export_alt      <- function(x) Arima(x, order = c(0,1,3),
                                         seasonal = list(order = c(0,0,1), period = s),
                                         include.drift = TRUE)     

fit_house_baseline  <- function(x) Arima(x, order = c(1,1,2),
                                         seasonal = list(order = c(0,1,1), period = s),
                                         include.drift = FALSE)     
fit_house_alt       <- function(x) Arima(x, order = c(1,1,2),
                                         seasonal = list(order = c(0,0,2), period = s),
                                         include.drift = TRUE)     


# this is for import only

sarima_seasonal_cv_1_vs_s <- function(y, fit_fun, s = frequency(y)) {
  stopifnot(frequency(y) == s)

  fc_fun <- function(x, h) forecast(fit_fun(x), h = h)

  e1 <- tsCV(y, forecastfunction = fc_fun, h = 1)
  es <- tsCV(y, forecastfunction = fc_fun, h = s)

  metr <- function(e, y, s) {
    data.frame(
      MAE   = mean(abs(e), na.rm = TRUE),
      RMSE  = sqrt(mean(e^2, na.rm = TRUE)),
      MASE1 = mean(abs(e), na.rm = TRUE) / mean(abs(diff(y, lag = 1)),  na.rm = TRUE),
      MASEs = mean(abs(e), na.rm = TRUE) / mean(abs(diff(y, lag = s)),  na.rm = TRUE),
      sMAPE = mean(200 * abs(e) / (abs(y) + abs(y - e)), na.rm = TRUE)
    )
  }

  dplyr::bind_rows(
    cbind(Horizon = "1-step",        metr(e1, y, s)),
    cbind(Horizon = paste0(s, "-step"), metr(es, y, s))
  )
}

plot_two_lines_mae_rmse <- function(cv_summary, title = "Seasonal CV: 1 vs s") {
  df_long <- cv_summary %>%
    dplyr::select(Horizon, MAE, RMSE) %>%
    tidyr::pivot_longer(c(MAE, RMSE), names_to = "Metric", values_to = "Value")

  ggplot(df_long, aes(x = Horizon, y = Value, color = Metric, group = Metric)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    labs(title = title, x = NULL, y = "Error", color = NULL) +
    theme_minimal(base_size = 12)
}
```



::: panel-tabset

### Trade import South korea vs USA

```{r}
fit_import_mine <- function(x) Arima(
  x,
  order   = c(0,1,2),
  seasonal= list(order = c(0,1,1), period = 12),
  include.drift = TRUE
)

cv_imp <- sarima_seasonal_cv_1_vs_s(import_ts, fit_import_mine, s = 12)

kable(cv_imp, digits = 4,
      caption = "Imports: Seasonal CV (1-step vs 12-step(s)) :ARIMA(0,1,2)(0,1,1)[12]  ") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped","hover","condensed","responsive"))

print( plot_two_lines_mae_rmse(cv_imp, "Imports — MAE & RMSE (1 vs 12)") )


```


### Trade export South korea vs USA

```{r,message= F,warning= F}
res_exp <- compare_two_models_fixedk(
  y = export_ts,
  fit_base = fit_export_baseline,
  fit_alt  = fit_export_alt,
  labels   = c("export model : ARIMA(0,1,1)(0,1,1)[12]", "export model : ARIMA(0,1,3)(0,0,1)[12]"),
  k = 120, s = 12, h = 12
)
kable(res_exp$table[, c("Horizon","MAE_base","MAE_alt","RMSE_base","RMSE_alt")],
      digits = 4, caption = "Exports — Horizon-wise errors (1..12)") |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped","hover","condensed","responsive"))
print(res_exp$plot_mae); print(res_exp$plot_rmse)


```


### Seoul housing price index 

```{r,message= F,warning= F}

res_house <- compare_two_models_fixedk(
  y = house_ts,
  fit_base = fit_house_baseline,
  fit_alt  = fit_house_alt,
  labels   = c("house index Model:ARIMA(1,1,2)(0,1,1)[12]  ", "house index Model:ARIMA(1,1,2)(0,0,2)[12]"),
  k = 120, s = 12, h = 12
)
kable(res_house$table[, c("Horizon","MAE_base","MAE_alt","RMSE_base","RMSE_alt")],
      digits = 4, caption = "Seoul HPI — Horizon-wise errors (1..12)") |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped","hover","condensed","responsive"))
print(res_house$plot_mae); print(res_house$plot_rmse)
```

:::


For cross-validation, we considered two cases. First, for trade imports, both the model-selection algorithm and auto.arima() chose the same model. Its performance is consistent: as the forecast horizon increases, MAE and RMSE also increase. Second, for Seoul housing prices and trade exports, the two methods selected different models, so we compared their performance directly. Across these comparisons, the model chosen by the model-selection algorithm outperforms the auto.arima() model, yielding lower MAE and RMSE.
